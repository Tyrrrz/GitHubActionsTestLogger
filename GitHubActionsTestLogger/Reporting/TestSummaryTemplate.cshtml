@using System
@using System.Collections.Generic
@using System.Linq
@using GitHubActionsTestLogger.GitHub
@using GitHubActionsTestLogger.Utils.Extensions

@inherits RazorBlade.HtmlTemplate

@functions
{
    public required string TestSuite { get; init; }

    public required string TargetFramework { get; init; }

    public required TestRunEndInfo TestRunEndInfo { get; init; }

    public required IReadOnlyList<TestResult> TestResults { get; init; }
}

<details>
    @{
        var overallOutcomeEmoji = TestRunEndInfo.OverallOutcome switch
        {
            TestOutcome.None => "⚪️",
            TestOutcome.Passed => "🟢",
            TestOutcome.Failed => "🔴",
            TestOutcome.Skipped => "🟡",
            _ => "\u2753"
        };
    }

    <summary>
        <b>@overallOutcomeEmoji @TestSuite</b> (@TargetFramework)
    </summary>

    @* This adds a margin that is smaller than <br> *@
    <p></p>

    <table>
        <th width="99999">✓&nbsp;&nbsp;Passed</th>
        <th width="99999">✘&nbsp;&nbsp;Failed</th>
        <th width="99999">↷&nbsp;&nbsp;Skipped</th>
        <th width="99999">∑&nbsp;&nbsp;Total</th>
        <th width="99999">⧗&nbsp;&nbsp;Elapsed</th>
        <tr>
            <td align="center">
                @(TestRunEndInfo.PassedTestCount > 0
                    ? TestRunEndInfo.PassedTestCount.ToString()
                    : "—")
            </td>
            <td align="center">
                @(TestRunEndInfo.FailedTestCount > 0
                    ? TestRunEndInfo.FailedTestCount.ToString()
                    : "—")
            </td>
            <td align="center">
                @(TestRunEndInfo.SkippedTestCount > 0
                    ? TestRunEndInfo.SkippedTestCount.ToString()
                    : "—")
            </td>
            <td align="center">
                @TestRunEndInfo.TotalTestCount
            </td>
            <td align="center">
                @TestRunEndInfo.Duration.ToHumanString()
            </td>
        </tr>
    </table>

    @{
        var testResultGroups = TestResults
            .GroupBy(r => r.Definition.TypeFullyQualifiedName, StringComparer.Ordinal)
            .Select(g => new
            {
                TypeFullyQualifiedName = g.Key,
                TypeName = g.First().Definition.TypeMinimallyQualifiedName,
                TestResults = g
                    .OrderByDescending(r => r.Outcome == TestOutcome.Failed)
                    .ThenByDescending(r => r.Outcome == TestOutcome.Passed)
                    .ThenBy(r => r.Definition.DisplayName, StringComparer.Ordinal)
                    .ToArray()
            })
            .OrderByDescending(g => g.TestResults.Any(r => r.Outcome == TestOutcome.Failed))
            .ThenByDescending(g => g.TestResults.Any(r => r.Outcome == TestOutcome.Passed))
            .ThenBy(g => g.TypeName, StringComparer.Ordinal);
    }

    <ul>
        @foreach (var testResultGroup in testResultGroups)
        {
            var failedTestCount = testResultGroup.TestResults.Count(r => r.Outcome == TestOutcome.Failed);

            <li>
                <b>@testResultGroup.TypeName</b>

                @if (failedTestCount > 0)
                {
                    @(" ")<i>(@failedTestCount failed)</i>
                }

                @* This adds a margin that is smaller than <br> *@
                <p></p>

                <ul>
                    @foreach (var testResult in testResultGroup.TestResults)
                    {
                        var outcomeEmoji = testResult.Outcome switch
                        {
                            TestOutcome.None => "⬜",
                            TestOutcome.Passed => "🟩",
                            TestOutcome.Failed => "🟥",
                            TestOutcome.Skipped => "🟨",
                            _ => "\u2753"
                        };

                        // Use the display name if it's different from the fully qualified name,
                        // otherwise use the minimally qualified name.
                        var testName = !string.Equals(
                            testResult.Definition.DisplayName,
                            testResult.Definition.FullyQualifiedName,
                            StringComparison.Ordinal)
                            ? testResult.Definition.DisplayName
                            : testResult.Definition.MinimallyQualifiedName;

                        // Test source permalink
                        var url = testResult.Definition.SourceFilePath?.Pipe(p => GitHubEnvironment.TryGenerateFilePermalink(p, testResult.Definition.SourceFileLineNumber));

                        <li>
                            @outcomeEmoji

                            @if (!string.IsNullOrWhiteSpace(url))
                            {
                                @(" ")<a href="@url">@testName</a>
                            }
                            else
                            {
                                @(" ")@testName
                            }

                            @if (!string.IsNullOrWhiteSpace(testResult.ErrorMessage))
                            {
                                WriteMarkdown(
                                    "```yml",
                                    testResult.ErrorMessage,
                                    testResult.ErrorStackTrace,
                                    "```"
                                );
                            }
                        </li>
                    }
                </ul>

                @* This adds a margin that is smaller than <br> *@
                <p></p>
            </li>
        }
    </ul>
</details>

@functions
{
    // We need to override the WriteLiteral(...) method to rewrite some literals
    // so that the generated HTML appears correctly in Markdown.
    protected override void WriteLiteral(string? value)
    {
        if (!string.IsNullOrEmpty(value))
        {
            base.WriteLiteral(
                value
                    // Remove indentation
                    .Replace("    ", "", StringComparison.Ordinal)
                    // Remove linebreaks
                    .Replace("\r", "", StringComparison.Ordinal)
                    .Replace("\n", "", StringComparison.Ordinal)
            );
        }
        else
        {
            base.WriteLiteral(value);
        }
    }

    // Using params here to write multiple lines as a workaround for the
    // fact that Razor does not support multiline raw string literals.
    private void WriteMarkdown(params IEnumerable<string?> lines)
    {
        // Two line breaks are required to separate markdown from HTML
        base.WriteLiteral("\n\n");

        foreach (var line in lines)
        {
            base.WriteLiteral(line);
            base.WriteLiteral("\n");
        }
    }
}